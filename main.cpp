#include <iostream>

#include <sstream>

using namespace std;

/* Создание класса "комплексные числа". Класс - это пользовательский тип данных, который может хранить в себе различные встроенные типы
и другие пользовательские классы. Класс - основа объектно-ориентированного программирования, поскольку через объекты (то есть, физические
экземпляры класса, хранящиеся в памяти компьютера, осуществляются досттаочно мощные алгоритмы и поддерживаются необходимые функции для
работы с классом.
Создание класса делится на два блока: создание переменных; и методов - то есть, функций, которые предназначены конкретно для работы с данными
класса. Переменные чаще всего находятся в блоке с меткой "private" - это означает, что обращаться к данным класса можно исключительно через
методы класса, из другой точки программы (например, функции main() ) нельзя напрямую обратится к переменным, только через методы класса. Поэтому
"private" так же называют "кишками" класса: если пользователь программы получит доступ к данному блоку, то работа класса может выйти из-под
контроля.
Интерфес (то есть, функции, которые может использовать пользователь для работы с классом) находится в блоке с меткой "public", поскольку
пользователь через данные методы использует данные созданного объекта класса.
Рассмотрим работу класса на примере данной программы
*/

class complex_t {
private:	
//Мы объявляем две переменные - составляющие комплексного числа - действительную и мнимую часть
  float real; //действительная часть числа
  float imag; //мнимая часть числа
  
public:
/* В каждом классе по умолчанию создаются как минимум две функции-члена (метода): конструктор и деструктор. Конструктор - это такой метод,
который инициализирует переменные класса при объявлении объекта класса. То есть, конструктор в принципе вызывается из точки программмы неявно,
где объявляется переменная типа пользовательского класса. Данный конструктор инициализирует нулями переменные класса, хотя в общем случае
конструктор может делать и более "умные" вещи, необходимые в определенном классе.
Конструктор и деструктор создается компилятором автоматически. Однако пользователь может самостоятельно создать конструктор, для этого
необходимо написать название класса со скобочками (возращаемого значения для конструктора писать не нужно, а аргументы конструктор может
принимать в общем случае и использовать их для инициализации переменных или для других действий с переменными).
Деструктор - это метод класса, который уничтожает данные объекта после последнего его использования. Функция деструктора объявляется как
~[Имя_Класса](), притом деструктор также не имеет возвращаемого значения и не принимает никаких аргументов. Деструктор всегда вызывается
автоматически при завершении работы программы с данным классом (например, когда объект покидает область видимости, или когда программа
производит аварийное завершение либо просто завершается). Как правило, деструктор используется по умолчанию, однако его необходимо явно
создать самому программисту в том случае, если в конструкторе выделяется память через операторы new или new[]. Кроме того, деструктор
почти никогда не вызывается явно, а используется программой автоматически*/
*/
  complex_t() {
  	real=0.0f; //инициализируем действительную и мнимую части комплексного числа нулями типа float
  	imag=0.0f;
  };

/*Функция сложения двух комплексных чисел. Следует обратить внимание, что функция возвращает объект нашего класса, принимает в качестве
аргументы другой объект пользовательского типа данных (класса). После закрывающей скобочки функции стоит ключевое слово const, не позволяющее
данному методу изменять передаваемые в функцию аргументы. То есть, это особая защита данных, которые передаются в функцию и потенциально
могут быть изменены.
Кроме того, отметим, что в качестве аргумента передается не сам объект, а ссылка на объект данных. Ссылка - это синоним имени переменной,
то есть, каждый раз, когда мы используем ссылку на переменную и изменяем ее, то изменяется и переменная, на которую данная ссылка указывает.
В данном случае ссылка объявляется так: "&other". В качестве аргументов нужно передавать именно ссылки объектов, иначе компилятор будет создавать
копии переменных, которые передаются в качестве аргументов, будет тратить время на поэлементное копирование данных класса в новый созданный объект
класса, и лишь потом передавать его для использования в функцию. Именно для экономии ресурсов компьютера (памяти и производительности) используется
передача аргументов по ссылкам*/
  complex_t add( complex_t &other ) const {
  	complex_t result; //создаем новый объект класса, именно тут используется созданный конструктор, инициализирующий реальную и мнимую часть нового класса числа нулями
  	result.real = other.real + this->real; //реальная часть суммы двух комплексных чисел - это сумма реальных чисел слагаемых
  	result.imag = other.imag + this->imag; //мнимая часть суммы двух комплексных чисел - это сумма мнимых чисел слагаемых
  	return result; //возвращаем созданный класс. Обратим внимание, что возвращаемое значение - не ссылка, поэтому компилятор сделает копию данного объекта, и в вызывающей функции будет использоваться именнно эта копия
  };
  
  /*Функция разности двух комплексных чисел. Она аналогична предыдущей, однако здесь акцентируем внимание на ключевом слове this.
  В каждый метод класса неявно передаеется указатель на исходный метод класса и создается переменная типа указателя на класс с именем this.
  Данной переменной присваивается значение указателя на класс, поэтому через слово this мы получаем доступ к исходному объекту. Так, получив
  указатель на объект мы можем обратиться к его переменным через оператор стрелочки -> - то есть, стрелочка позволяет получить доступ к данным класса
  и методам класса, если известен адрес класса. Аналогично, если создается объект класса не через указатель (как other), то доступ к данным и методам
  класса производится через оператор точки ".".*/
  complex_t sub( complex_t &other ) const {
  	complex_t result; //создаем объект класса
  	result.real = this->real - other.real;
  	result.imag = this->imag - other.imag;
  	return result; //возвращаем копию получившегося числа
  };
  
  //Функция произведения двух комплексных чисед
  complex_t mul( complex_t &other ) const {
  	complex_t result;
    
    //По формуле произведения двух комплексных чисел получаем реальную и мнимую части полученного комплексного числа
	result.real = this->real*other.real - this->imag*other.imag;
	result.imag = this->imag*other.real + this->real*other.imag;
	return result;
  };
  
  //Функция деления двух комплексных чисел
  complex_t div( complex_t &other ) const {
  	complex_t result;
  	float x = other.real*other.real + other.imag*other.imag;
  	
    //Производим деление по формуле деления двух комплексных чисел
  	if (x != 0) {
  		result.real = (this->real*other.real + this->imag*other.imag) / x;
		result.imag = (this->imag*other.real - this->real*other.imag) / x;
		return result;
	  }
    //Если деление произвести невозможно, то выводим сообщение об ошибке и завершаем программу
	else {
	    cout << "You can`t make this action!";
	  	exit(0);
	}
  };
  
  //Функция, которая инициализирует переменные класса не через конструктор, а через введенные пользователем данные. В качестве аргумента и возвращаемого значения принимается считанная с консоли строка
  std::istream & read( std::istream & stream ) {
	char symbol;
	stream >> symbol && symbol == '(' && 
	stream >> this->real && 
	stream >> symbol && symbol == ',' && 
	stream >> this->imag && 
	stream >> symbol && symbol == ')';
	return stream;
  };
  
  //Функция, которая выводит комплексное число на экран монитора
  std::ostream & write( std::ostream & stream ) {
  	stream << '(' << this->real << ", " << this->imag << ')';
  	return stream;
  };
  
} one, two, result; //создание трех переменных типа нашего класса, которые существуют в памяти до начала программы, а не создаются во время выполнения

int main () {
	
	std::string line;
	char op;
	
	cout << "Write complex numbers by (r1, i1) op (r2, i2)" << endl << endl;
	
  //Считаывание комплексного числа с консоли
	std::getline( std::cin, line );
	std::istringstream stream( line );
	
  //Если были верно считаны два комплексных числа и знак производимой над ними операцией, то программа продолжает работать, в противном случае завершается 
	if (one.read (stream) && stream >> op && two.read (stream)) {
		cout << endl;
    
    //Выбор функции в зависимости от указанной операции
		switch (op) {
			case '+': {
				result = one.add(two);
				break;
			}
			case '-': {
				result = one.sub(two);
				break;
			}
			case '/': {
				result = one.div(two);
				break;
			}
			case '*': {
				result = one.mul(two);
				break;
			}
      
      //Если ни указанная операция не соответствует данным 4, то программа аварийно завершает работу
			default: {
				cout << "An error has occured while reading input data";
	  			exit(0);
			}
		}
    
    //Вывод на экран компьютера полученного комплексного числа
		result.write (cout) ;
	}
	else {
		cout << endl << "An error has occured while reading input data";
	}
	
	cin.get();
	
	return 0;
}
